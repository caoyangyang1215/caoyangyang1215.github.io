[{"title":"用 java 实现 spring 的 IOC 容器","url":"/2022/04/19/javaIOC/","content":"\n用 java 实现 spring 的 IOC 容器，阅读 tiny-spring 之后整理，从 step-1 到 step-6 由简入繁\n\n\n\nstep1IOC 最基本的两个角色，容器 和 bean 本身，bean 被存放到容器中，需要使用的时候容器将 bean 提供给我们那么我们需要一个类，作为 容器，存放 bean最简单的做法是，定义一个 BeanFactory 类作为容器，一个 map 属性以键值对的形式存放 bean name 和 bean 对象\npublic BeanFactory &#123;\tprivate Map&lt;String,Object&gt; beanMap = new HashMap&lt;String,Object&gt;();\t\tpublic Object getBean(String name) &#123;\t\treturn beanMap.get(name);\t&#125;\tpublic void registerBean(String name, Object bean) &#123;\t\tbeanMap.put(name,bean);\t&#125;&#125;\n\n现在就可以调用 registerBean 方法把 bean 放入到容器中，getBean 获取 bean了\n将上面的方法优化一下\n定义一个 BeanDefinition 用来封装 bean，使用对象去封装 bean 的好处是，除了存放 bean 本身，还可以定义其他的属性去存放一些 bean 的其他信息\npublic class BeanDefinition &#123;\tprivate Object bean;    public BeanDefinition(Object bean) &#123;        this.bean = bean;    &#125;    public Object getBean() &#123;        return bean;    &#125;&#125;\n\n\n\n再将前面的容器对应修改，逻辑还是一样的\npublic class BeanFactory &#123;\tprivate Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();\tpublic Object getBean(String name) &#123;\t\treturn beanDefinitionMap.get(name).getBean();\t&#125;\tpublic void registerBeanDefinition(String name, BeanDefinition beanDefinition) &#123;\t\tbeanDefinitionMap.put(name, beanDefinition);\t&#125;&#125;\n\n\n\n容器完成了，定义一个类作为 bean，用作测试\npublic class HelloWorldServiceImpl implements HelloWorldService &#123;    @Override    public void helloWorld() &#123;        System.out.println(&quot;hello world&quot;);    &#125;&#125;\n\n\n\nexample main 示例初始化 BeanFactory 容器初始化一个 HelloServiceImpl 对象，存放进 BeanDefinition 的 bean 属性中以 helloServiceImpl 作为 键(bean name)，beanDefinition 作为值存放进 BeanFactory 的 map 中然后就可以调用 getBean 方法，通过 bean name 得到对应的 bean 对象\npublic class ExampleMain &#123;    public static void main(String[] args) &#123;               BeanFactory beanFactory = new BeanFactory();               BeanDefinition beanDefinition = new BeanDefinition(new HelloWorldServiceImpl());        beanFactory.registerBeanDefinition(&quot;helloWorldServiceImpl&quot;,beanDefinition);           HelloWorldService helloWorldService = (HelloWorldService)beanFactory.getBean(&quot;helloWorldServiceImpl&quot;);        helloWorldService.helloWorld();    &#125;&#125;\n\n\n\nstep2在第一步中，做到了 定义 BeanFactory 容器，定义 BeanDefinition 用来封装 bean，然后初始化 bean 放入容器，最后可以通过 bean name 去获取 bean我们在初始化 bean 的时候是这么做的：把 HelloWorldServiceImpl 初始化好之后再 set 进属性\nBeanDefinition beanDefinition = new BeanDefinition(new HelloWorldServiceImpl());\n\n\n\nIOC 的原则是 bean 的初始化应该交给容器去做，这显然不是我们想要的，如何让容器去初始化 bean 呢？首先，容器肯定需要知道要初始化哪一个类step-1 中，在初始化 BeanDefinition 的时候就已经把 bean 实例存放在 BeanDefinition 中了\nBeanDefinition beanDefinition = new BeanDefinition(new HelloWorldServiceImpl());\n\n\n\n而下面的一步，beanFactory 登记 bean，除了存放进 map，就没有做任何事情\nbeanFactory.registerBeanDefinition(&quot;helloWorldServiceImpl&quot;,beanDefinition);\n\n\n\n要让容器去初始化 bean，那么在 new BeanDefinition 的时候就不初始化 bean但是要存放一些信息，后面 BeanFactory 根据这些信息去初始化 bean\nBeanDefinition 新增属性beanClassName 存放 bean 的全路径名beanClass 存放 bean 的 calss 对象setBeanClassName 的时候，根据全路径，使用 java 反射得到类对象存放到 beanClass 属性中\npublic class BeanDefinition &#123;\tprivate Object bean;\tprivate Class beanClass;\tprivate String beanClassName;\tpublic BeanDefinition() &#123;\t&#125;\tpublic void setBean(Object bean) &#123;\t\tthis.bean = bean;\t&#125;\tpublic Class getBeanClass() &#123;\t\treturn beanClass;\t&#125;\tpublic void setBeanClass(Class beanClass) &#123;\t\tthis.beanClass = beanClass;\t&#125;\tpublic String getBeanClassName() &#123;\t\treturn beanClassName;\t&#125;\tpublic void setBeanClassName(String beanClassName) &#123;\t\tthis.beanClassName = beanClassName;\t\ttry &#123;\t\t\tthis.beanClass = Class.forName(beanClassName);\t\t&#125; catch (ClassNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic Object getBean() &#123;\t\treturn bean;\t&#125;&#125;\n\n\n\nstep-1 的 BeanFactory 是一个 class 对象，为了保证扩展性把容器特性抽象出来成为一个接口定义两个必要方法 获取 bean 和 注册 bean\npublic interface BeanFactory &#123;    Object getBean(String name);    void registerBeanDefinition(String name, BeanDefinition beanDefinition);&#125;\n\n\n\n抽象类 AbstractBeanFactory 实现接口，存放 bean 的 map 在此处定义这里面定义了一个抽象方法 doCreateBean这个方法就是我们用来初始化 bean 的参数 BeanDefinition 封装了类的信息，容器得到类的信息去初始化 bean\npublic abstract class AbstractBeanFactory implements BeanFactory &#123;    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();    @Override    public Object getBean(String name) &#123;        return beanDefinitionMap.get(name).getBean();    &#125;    @Override    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) &#123;               Object bean = doCreateBean(beanDefinition);                beanDefinition.setBean(bean);               beanDefinitionMap.put(name, beanDefinition);    &#125;    protected abstract Object doCreateBean(BeanDefinition beanDefinition);&#125;\n\n\n\n定义 AutowireCapableBeanFactory 做为一个实现\npublic class AutowireCapableBeanFactory extends AbstractBeanFactory &#123;    @Override    protected Object doCreateBean(BeanDefinition beanDefinition) &#123;        try &#123;            Object bean = beanDefinition.getBeanClass().newInstance();            return bean;        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n\n\nexample main\npublic class ExampleMain &#123;    public static void main(String[] args) &#123;        // 初始化 BeanFactory        BeanFactory beanFactory = new AutowireCapableBeanFactory();        // 初始化 BeanDefinition        BeanDefinition beanDefinition = new BeanDefinition();        /**         *  step1 是直接实例化出来一个 bean，这里把这一步交给了容器，也就是让 BeanFactory 去初始化         *  给 BeanDefinition 中的 类名赋值，全路径名         *  BeanDefinition 根据类全路径名称，反射出来一个 Class 对象         */        beanDefinition.setBeanClassName(&quot;common_step2.HelloWorldService&quot;);       /**        * 这一步会从 BeanDefinition 中拿到之前存放的 Class 对象，通过 newInstance() 方法实例化出来一个 Bean        * 存放进 BeanDefinition 的 属性中        * 然后把 BeanName 和 BeanDefinition 通过键值对的方式存放进 BeanFactory 的 ConcurrentHashMap 中去        * **/        beanFactory.registerBeanDefinition(&quot;helloWorldService&quot;,beanDefinition);        /**         * 获取 bean         */        HelloWorldService helloWorldService = (HelloWorldService)beanFactory.getBean(&quot;helloWorldService&quot;);        helloWorldService.helloWorld();    &#125;&#125;\n\n\n\nstep3将容器逐步完善，第二步中把实例化 bean 的操作交给了 BeanFactory 容器实现了 spring 的控制反转，接下来考虑一些另一个特性：依赖注入\n一般情况 bean 都是会带有自己的属性的，如何去注入属性呢\n在前几步的基础上，新建 PropertyValue 对象和 PropertyValues 对象\nPropertyValuename属性对应 bean 的属性名称value 属性对应 bean 的属性值一个 PropertyValue 对象即对应一个 bean 的属性\npublic class PropertyValue &#123;    private final String name;    private final Object value;    public PropertyValue(String name, Object value) &#123;        this.name = name;        this.value = value;    &#125;    public String getName() &#123;        return name;    &#125;    public Object getValue() &#123;        return value;    &#125;&#125;\n\n\n\nPropertyValues 存放多个 PropertyValue此对象会被放进 BeanDefinition\npublic class PropertyValues &#123;\tprivate final List&lt;PropertyValue&gt; propertyValueList = new ArrayList&lt;PropertyValue&gt;();\tpublic PropertyValues() &#123;\t&#125;\tpublic void addPropertyValue(PropertyValue pv) &#123;        //TODO:这里可以对于重复propertyName进行判断，直接用list没法做到\t\tthis.propertyValueList.add(pv);\t&#125;\tpublic List&lt;PropertyValue&gt; getPropertyValueLists() &#123;\t\treturn this.propertyValueList;\t&#125;&#125;\n\n\n\nBeanDefinition 中新增一个 PropertyValues 属性\npublic class BeanDefinition &#123;\tprivate Object bean;\tprivate Class beanClass;\tprivate String beanClassName;\t// 新增        private PropertyValues propertyValues;\tpublic BeanDefinition() &#123;\t&#125;\tpublic void setBean(Object bean) &#123;\t\tthis.bean = bean;\t&#125;\tpublic Class getBeanClass() &#123;\t\treturn beanClass;\t&#125;\tpublic void setBeanClass(Class beanClass) &#123;\t\tthis.beanClass = beanClass;\t&#125;\tpublic String getBeanClassName() &#123;\t\treturn beanClassName;\t&#125;\tpublic void setBeanClassName(String beanClassName) &#123;\t\tthis.beanClassName = beanClassName;\t\ttry &#123;\t\t\tthis.beanClass = Class.forName(beanClassName);\t\t&#125; catch (ClassNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic Object getBean() &#123;\t\treturn bean;\t&#125;    public PropertyValues getPropertyValues() &#123;        return propertyValues;    &#125;    public void setPropertyValues(PropertyValues propertyValues) &#123;        this.propertyValues = propertyValues;    &#125;&#125;\n\n\n\nstep4经过前三步的逐步优化，已经实现容器实例化 bean 并注入属性值\n\n如果一个 bean 有很多属性值的话，代码会写的非常长所以这一步实现类似 sping 的 xml 配置方式在 xml 里面配置 bean 名称，bean 路径，bean 属性名，bean 属性值按照 spring 的方法，新建一个 xml 文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;    &lt;bean name=&quot;helloWorldService&quot; class=&quot;us.codecraft.tinyioc.HelloWorldService&quot;&gt;        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n既然有了 xml 文件，那肯定需要去解析 xml 文件，获得各个节点的内容在前面的基础上，定义 Resource 接口，UrlResource实现接口此对象的作用是根据 xml 文件的 URL 对象得到 xml 文件的 输入流\n/** * Resource是spring内部定位资源的接口。 * @author yihua.huang@dianping.com */public interface Resource &#123;    InputStream getInputStream() throws IOException;&#125;public class UrlResource implements Resource &#123;    private final URL url;    public UrlResource(URL url) &#123;        this.url = url;    &#125;    @Override    public InputStream getInputStream() throws IOException&#123;        URLConnection urlConnection = url.openConnection();        urlConnection.connect();        return urlConnection.getInputStream();    &#125;&#125;\n\n\n\n定义一个 ResourceLoader 类，一个 getResource() 方法在根路径下根据文件名找到对应的 xml 文件返回一个 UrlResource 对象\npublic class ResourceLoader &#123;    public Resource getResource(String location)&#123;        /**         * location 为 xml 文件的 路径+名称         * this.getClass().getClassLoader() 表示 classpath 根目录         * 返回一个 URL 对象         */        URL resource = this.getClass().getClassLoader().getResource(location);        return new UrlResource(resource);    &#125;&#125;\n\n\n\n定义解析 xml 文件的接口BeanDefinitionReaderAbstractBeanDefinitionReader实现接口一个 map 属性 registry从 xml 中解析出来，封装好的 BeanDefinition 对象通过键值对的方式存放在 map 中一个 ResourceLoader 属性\npublic interface BeanDefinitionReader &#123;    void loadBeanDefinitions(String location) throws Exception;&#125;public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader &#123;    /**     * 从 xml 中读取到的文件封装到 BeanDefinition 对象之后     * 以 bean name 为键，BeanDefinition 为值得方式放入 此 map 中     */    private Map&lt;String,BeanDefinition&gt; registry;    /**     * ResourceLoader 对象     * 主要作用为读取 xml 文件，得到 xml 文件的 URl 对象     */    private ResourceLoader resourceLoader;    protected AbstractBeanDefinitionReader(ResourceLoader resourceLoader) &#123;        this.registry = new HashMap&lt;String, BeanDefinition&gt;();        this.resourceLoader = resourceLoader;    &#125;    public Map&lt;String, BeanDefinition&gt; getRegistry() &#123;        return registry;    &#125;    public ResourceLoader getResourceLoader() &#123;        return resourceLoader;    &#125;&#125;\n\n\n\nXmlBeanDefinitionReader 继承 AbstractBeanDefinitionReader 实现方法loadBeanDefinitions 方法中，得到 xml 文件的 输入流，然后去解析doLoadBeanDefinitions 方法，通过输入流得到 xml 的 Document 对象registerBeanDefinitions 方法，通过 Document 对象得到 xml 根节点parseBeanDefinitions 方法，通过根节点得到所有的子节点在循环中，解析每一个子节点processBeanDefinition 方法，得到 bean 标签的 name 和 class 的值processProperty 方法，再去解析 bean 标签下面的 property 标签的内容将得到的 nama 和 value 的值，封装到 BeanDefinition 中再把 BeanDefinition 和 bean name 以键值对的形式存放到 map 属性中\npublic class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader &#123;\tpublic XmlBeanDefinitionReader(ResourceLoader resourceLoader) &#123;\t\tsuper(resourceLoader);\t&#125;\t@Override\tpublic void loadBeanDefinitions(String location) throws Exception &#123;\t\t/**\t\t * 调用继承的 ResourceLoader 的 getResource 方法\t\t * 该方法返回一个 Resource 类型的对象 UrlResource\t\t * 得到 根目录下面的 名为 location 文件的 URL 对象\t\t * 将 URL 对象存放进 UrlResource 中返回\t\t * 调用 UrlResource 对象的 getInputStream 方法得到一个 inputStream 对象\t\t */\t\tInputStream inputStream = getResourceLoader().getResource(location).getInputStream();\t\t/**\t\t * 解析 xml\t\t */\t\tdoLoadBeanDefinitions(inputStream);\t&#125;\t/**\t * 通过 xml 文件输入流\t * 得到 xml 文件的 Document 对象\t * @param inputStream\t * @throws Exception\t */\tprotected void doLoadBeanDefinitions(InputStream inputStream) throws Exception &#123;\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\t\tDocumentBuilder docBuilder = factory.newDocumentBuilder();\t\tDocument doc = docBuilder.parse(inputStream);\t\t/**\t\t * 解析 bean\t\t */\t\tregisterBeanDefinitions(doc);\t\tinputStream.close();\t&#125;\t/**\t * 通过 Document 对象解析 xml\t * @param doc\t */\tpublic void registerBeanDefinitions(Document doc) &#123;\t\t/**\t\t * 得到根节点\t\t */\t\tElement root = doc.getDocumentElement();\t\tparseBeanDefinitions(root);\t&#125;\t/**\t * 遍历根节点 &lt;beans&gt;&lt;/beans&gt; 的子节点 NodeList\t * @param root\t */\tprotected void parseBeanDefinitions(Element root) &#123;\t\tNodeList nl = root.getChildNodes();\t\tfor (int i = 0; i &lt; nl.getLength(); i++) &#123;\t\t\tNode node = nl.item(i);\t\t\tif (node instanceof Element) &#123;\t\t\t\tElement ele = (Element) node;\t\t\t\tprocessBeanDefinition(ele);\t\t\t&#125;\t\t&#125;\t&#125;\t/**\t * 此处的 Element 表示 &lt;bean&gt;&lt;/bean&gt;\t * 获取 bean 标签里的 name 和 class 属性值\t * 初始化 BeanDefinition\t * @param ele\t */\tprotected void processBeanDefinition(Element ele) &#123;\t\tString name = ele.getAttribute(&quot;name&quot;);\t\tString className = ele.getAttribute(&quot;class&quot;);        BeanDefinition beanDefinition = new BeanDefinition();\t\t/**\t\t * 解析 bean 标签下面的 property 标签，遍历 name value\t\t * 将解析完成的数据封装成 PropertyValue 放进 BeanDefinition 的 PropertyValues 属性中\t\t */\t\tprocessProperty(ele,beanDefinition);\t\t/**\t\t * BeanDefinition className 属性赋值，同时反射出 class 对象给 class 属性赋值\t\t */        beanDefinition.setBeanClassName(className);\t\t/**\t\t * 将 bean name 和对应的 BeanDefinition 对象以键值对的形式存放进本类中的 HashMap 中(继承自抽象类)\t\t * 后面初始化 BeanFactory 并 注册 bean 的时候从这里取值\t\t */\t\tgetRegistry().put(name, beanDefinition);\t&#125;\t/**\t * 解析 &lt;bean&gt;&lt;/bean&gt; 下面的 &lt;property&gt;&lt;/property&gt; 中的 name 和 value\t * 放进 PropertyValue 中\t * 给 BeanDefinition 中的 list 赋值\t * @param ele\t * @param beanDefinition\t */    private void processProperty(Element ele,BeanDefinition beanDefinition) &#123;        NodeList propertyNode = ele.getElementsByTagName(&quot;property&quot;);        for (int i = 0; i &lt; propertyNode.getLength(); i++) &#123;            Node node = propertyNode.item(i);            if (node instanceof Element) &#123;                Element propertyEle = (Element) node;                String name = propertyEle.getAttribute(&quot;name&quot;);                String value = propertyEle.getAttribute(&quot;value&quot;);                beanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name,value));            &#125;        &#125;    &#125;&#125;\n\n\n\n上面方法已经将 xml 文件解析完成，BeanDefinition 已经存放进了 map 中同样的，此时的 BeanDefinition 中的 bean 属性还是空的，bean 未被实例化接下来只需要从 map 取出数据，再使用 BeanFactory 容器把 bean 放如工厂就行了AutowireCapableBeanFactory 与 step-3 相同，没有做改动\nexample main\npublic class ExampleMain &#123;    public static void main(String[] args) &#123;        // 初始化 BeanFactory        BeanFactory beanFactory = new AutowireCapableBeanFactory();        // 初始化 BeanDefinition        BeanDefinition beanDefinition = new BeanDefinition();        beanDefinition.setBeanClassName(&quot;common_step3.HelloWorldService&quot;);        // 初始化 PropertyValues 对象        PropertyValues propertyValues = new PropertyValues();        /**         * 实例化一个 PropertyValue 对象，赋值 name = ”text“ value = ”Hello World“         * 对应的 Bean text 属性，值 “Hello World”         * 把 PropertyValue 放进 PropertyValues 的 List 中         */        propertyValues.addPropertyValue(new PropertyValue(&quot;text&quot;,&quot;Hello World&quot;));        /**         * 把 PropertyValues 放进 BeanDefinition 的 属性中         */        beanDefinition.setPropertyValues(propertyValues);        /**         * 注入 bean 到容器中，与上一步相同，多了一步给 bean 注入属性值的方法         */        try &#123;            beanFactory.registerBeanDefinition(&quot;helloWorldService&quot;,beanDefinition);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        // 获取 Bean        HelloWorldService helloWorldService = (HelloWorldService)beanFactory.getBean(&quot;helloWorldService&quot;);        helloWorldService.helloWorld();    &#125;&#125;\n\n\n\nstep5上一步实现了 xml 配置的形式，去解析配置文件，实现 bean 的自动装配但是有一个问题，无法处理 bean 和 bean 之间的依赖例如HelloWorldService 中有一个 OutputService 对象\npublic class HelloWorldService &#123;        private String text;        private OutputService outputService;        public void helloWorld()&#123;        outputService.output(text);    &#125;        public void setText(String text) &#123;        this.text = text;    &#125;        public void setOutputService(OutputService outputService) &#123;        this.outputService = outputService;    &#125;&#125;\n\nOutputService 中有一个 HelloWorldService 对象\npublic class OutputService &#123;    private HelloWorldService helloWorldService;    public void output(String text)&#123;        System.out.println(text);    &#125;    public void setHelloWorldService(HelloWorldService helloWorldService) &#123;        this.helloWorldService = helloWorldService;    &#125;\n\n这种形式的话，使用上一步的方式就无法实现 bean 中注入 另一个 bean为了处理 baen 和 bean 之间的依赖关系定义一个 BeanReference 类，当一个类中出现对另一个类的引用时候使用它\npublic class BeanReference &#123;    private String name;    private Object bean;    public BeanReference(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Object getBean() &#123;        return bean;    &#125;    public void setBean(Object bean) &#123;        this.bean = bean;    &#125;&#125;\n\nxml 配置文件按照 sprin 的写法修改ref 表示对其他 bean 的引用\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;    &lt;bean name=&quot;outputService&quot; class=&quot;common_step5.OutputService&quot;&gt;        &lt;property name=&quot;helloWorldService&quot; ref=&quot;helloWorldService&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean name=&quot;helloWorldService&quot; class=&quot;common_step5.HelloWorldService&quot;&gt;        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;outputService&quot; ref=&quot;outputService&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n相应的解析 xml 文件的类 XmlBeanDefinitionReader 需要调整类中解析 property 标签的方法 processProperty 需要对 有 ref 这个属性的标签做相应的操作\n之前的解析方式是解析 property 标签的 name 和 value 属性的值对应的存放到 BeanDefinition propertyValues 属性中这里添加了 如果 property 标签中有 ref 这个属性在就表示，是对另一个 bean 的引用，ref 的值 就为引用的 bean 的 name创建一个 BeanReference 对象，把 bean name 存放进去然后把 BeanReference 对象存放到 PropertyValue 对象的 value 属性中后面就一样的把 PropertyValue 存放到 BeanDefinition 中去\nprivate void processProperty(Element ele, BeanDefinition beanDefinition) &#123;\t\tNodeList propertyNode = ele.getElementsByTagName(&quot;property&quot;);\t\tfor (int i = 0; i &lt; propertyNode.getLength(); i++) &#123;\t\t\tNode node = propertyNode.item(i);\t\t\tif (node instanceof Element) &#123;\t\t\t\tElement propertyEle = (Element) node;\t\t\t\tString name = propertyEle.getAttribute(&quot;name&quot;);\t\t\t\tString value = propertyEle.getAttribute(&quot;value&quot;);\t\t\t\tif (value != null &amp;&amp; value.length(P) &gt; 0) &#123;\t\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, value));\t\t\t\t&#125; else &#123;\t\t\t\t\tString ref = propertyEle.getAttribute(&quot;ref&quot;);\t\t\t\t\tif (ref == null || ref.length() == 0) &#123;\t\t\t\t\t\tthrow new IllegalArgumentException(&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;\t\t\t\t\t\t\t\t+ name + &quot;&#x27; must specify a ref or value&quot;);\t\t\t\t\t&#125;\t\t\t\t\tBeanReference beanReference = new BeanReference(ref);\t\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, beanReference));\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\n\n完成之后，XmlBeanDefinitionReader 中的 registry map 中就存放了所有的 需要放进 容器的 bean name 和对应的 BeanDefinition 对象BeanDefinition 对象中的 PropertyValues 属性里的 PropertyValue 对象value 属性有两种类型：String 或者 BeanReference 对象下面解析的时候对这两种类型做判断，分别做不同的操作\n对 AbstractBeanFactory 做一些调整getBean 方法从 map 中拿到 bean，如果 bean 不存在，调用 doCreateBean 方法去初始化 bean同时为了解决循环依赖的问题，我们使用lazy-init的方式，将createBean的事情放到getBean的时候才执行，是不是一下子方便很多？这样在注入bean的时候，如果该属性对应的bean找不到，那么就先创建！因为总是先创建后注入，所以不会存在两个循环依赖的bean创建死锁的问题。新增一个 list 集合 beanDefinitionNames 存放 bean 的 name在这里 registerBeanDefinition 所做的只是将bean name 和对应的 BeanDefinition 存放进 map 里面bean name 存放进 list 里面\npreInstantiateSingletons 方法用来初始化所有的 bean 到容器中\npublic abstract class AbstractBeanFactory implements BeanFactory &#123;\tprivate Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();\tprivate final List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;String&gt;();\t@Override\tpublic Object getBean(String name) throws Exception &#123;\t\tBeanDefinition beanDefinition = beanDefinitionMap.get(name);\t\tif (beanDefinition == null) &#123;\t\t\tthrow new IllegalArgumentException(&quot;No bean named &quot; + name + &quot; is defined&quot;);\t\t&#125;\t\tObject bean = beanDefinition.getBean();\t\tif (bean == null) &#123;\t\t\tbean = doCreateBean(beanDefinition);\t\t&#125;\t\treturn bean;\t&#125;\t@Override\tpublic void registerBeanDefinition(String name, BeanDefinition beanDefinition) throws Exception &#123;\t\tbeanDefinitionMap.put(name, beanDefinition);\t\tbeanDefinitionNames.add(name);\t&#125;\tpublic void preInstantiateSingletons() throws Exception &#123;\t\tfor (Iterator it = this.beanDefinitionNames.iterator(); it.hasNext();) &#123;\t\t\tString beanName = (String) it.next();\t\t\tgetBean(beanName);\t\t&#125;\t&#125;\t/**\t * 初始化bean\t *\t * @param beanDefinition\t * @return\t */\tprotected abstract Object doCreateBean(BeanDefinition beanDefinition) throws Exception;\n\nAutowireCapableBeanFactory 中 遍历 BeanDefinition 中 PropertyValue 并将值赋值给 bean 中对应的属性方法applyPropertyValues 也要做调整PropertyValue 的 value 可能是一个字符串，也可能是一个 BeanReference 对象如果对应的是一个 BeanReference 对象，表示 bean 中的该属性是一个其他 bean 的对象那么就从 容器 中，根据 bean name 名称去得到该对象的实例赋值给 bean实例还不存在？调用 doCreateBean 方法去创建\nprotected void applyPropertyValues(Object bean, BeanDefinition mbd) throws Exception &#123;\t\t/*n++;\t\tSystem.out.println(&quot;NO.&quot;+n+&quot; ==&gt; applyPropertyValues()&quot;);*/\t\tfor (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;\t\t\tField declaredField = bean.getClass().getDeclaredField(propertyValue.getName());\t\t\tdeclaredField.setAccessible(true);\t\t\tObject value = propertyValue.getValue();\t\t\tif (value instanceof BeanReference) &#123;\t\t\t\tBeanReference beanReference = (BeanReference) value;\t\t\t\t/**\t\t\t\t * 为 bean 注入 bean 的操作，在这一步\t\t\t\t * 如果 为 bean1 注入 bean2\t\t\t\t * 两个 bean 都需要在放入到容器中\t\t\t\t * 等查找到 某一个 bean 中依赖了另一个 bean\t\t\t\t * 只需要在容器中找到被依赖的 bean 放入\t\t\t\t */\t\t\t\tvalue = getBean(beanReference.getName());\t\t\t&#125;\t\t\tdeclaredField.set(bean, value);\t\t&#125;\t&#125;\n\nexample main\npublic class ExampleMain &#123;    public static void main(String[] args) throws Exception &#123;        /**         * step-5 处理了 bean 和 bean 之间的注入         * 为 bena 注入 bean         */        // 1.读取配置        XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());        xmlBeanDefinitionReader.loadBeanDefinitions(&quot;tinyioc.xml&quot;);        // 2.初始化BeanFactory并注册bean        AbstractBeanFactory beanFactory = new AutowireCapableBeanFactory();        for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());        &#125;        // 3.初始化bean        beanFactory.preInstantiateSingletons();        // 4.获取bean        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(&quot;helloWorldService&quot;);        helloWorldService.helloWorld();            &#125;&#125;\n\n\n\nstep6之前的 step-1 到 step-5 已经基本实现了 spring IOC 的功能但是使用起来比较麻烦回想一下之前使用 spring 的时候一般方法会这样写\nApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)HelloWorldService helloWorldService = ac.getBean(HelloWorldService.class);\n\n更加简洁优雅，这一步按照此方式进行优化定义一个 ApplicationContext 接口继承 BeanFactory 接口\npublic interface ApplicationContext extends BeanFactory &#123;&#125;\n\n定义一个抽象类 AbstractApplicationContext 实现 ApplicationContext 接口refresh 方法在子类进行实现，用来初始化 bean\npublic abstract class AbstractApplicationContext implements ApplicationContext &#123;    protected AbstractBeanFactory beanFactory;    public AbstractApplicationContext(AbstractBeanFactory beanFactory) &#123;        this.beanFactory = beanFactory;    &#125;    public void refresh() throws Exception&#123;    &#125;    @Override    public Object getBean(String name) throws Exception &#123;        return beanFactory.getBean(name);    &#125;&#125;\n\nClassPathXmlApplicationContext 继承抽象类 AbstractApplicationContext实现 refresh 方法与 step-5 比较，核心代码没有修改只是将初始化 AutowireCapableBeanFactory 容器XmlBeanDefinitionReader 解析 xml 文件初始化 bean 的操作 都封装到了这里面\npublic class ClassPathXmlApplicationContext extends AbstractApplicationContext &#123;\t\tprivate String configLocation;\tpublic ClassPathXmlApplicationContext(String configLocation) throws Exception &#123;\t\tthis(configLocation, new AutowireCapableBeanFactory());\t&#125;\tpublic ClassPathXmlApplicationContext(String configLocation, AbstractBeanFactory beanFactory) throws Exception &#123;\t\tsuper(beanFactory);\t\tthis.configLocation = configLocation;\t\trefresh();\t&#125;\t@Override\tpublic void refresh() throws Exception &#123;\t\tXmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());\t\txmlBeanDefinitionReader.loadBeanDefinitions(configLocation);\t\tfor (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;\t\t\tbeanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());\t\t&#125;\t\t/**\t\t * Add by me\t\t * 源代码中没有这一步\t\t * \t\t */\t\tbeanFactory.preInstantiateSingletons();\t&#125;&#125;\n\nexample main\npublic class ExampleMain &#123;    public static void main(String[] args) throws Exception &#123;        /**         * 熟悉的 ApplicationContext         *          */        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;tinyioc.xml&quot;);        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);        helloWorldService.helloWorld();    &#125;&#125;\n\n封装好之后，初始化 bean 只需一行代码就可以完成\n","tags":["java","ioc"]},{"title":"java基本数据类型","url":"/2022/04/23/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"\n温故知新系列\n\n\n\n\n二进制\n\n首先回顾一下二进制\n\n一个整数，按照绝对值大小转换成的二进制数叫做 原码\n将二进制数按位取反，叫做反码\n将反码 +1，叫做 补码\n\n\n负数 是以它绝对值的二进制的 补码 形式存储的\n\n例如一个字节的数据 -8，它的二进制数据是多少呢？\n首先 -8 的绝对值为 8\n8 的二进制数据为 100\n一个字节也就是：00000100\n反码为：11111011\n+1 补码为：11111100\n那么 -8 的二进制形式就为：11111100\n​\t\t\t\t\t\t\t\t\t\n基本数据类型java 中有 八种基本数据类型\n1 byte 字节类型java 中 byte 字节类型大小为 8 个二进制位\t0000 0000\n并且因为其带有符号：正数或者负数，所以可以表示的大小为 -128 ～ 127\n为什么会是这样呢？\nbyte n = 6;\n\n6 的二进制数据为 110 ，那么在内存中 n 的存储形式为\n\n\n\n0\n0\n0\n0\n0\n1\n1\n0\n\n\n\n其中，第一个二进制位的 0，表示这是一个正数还是负数\n那么也就是说这八个二进制位能表示的最大正数为\n\n\n\n0\n1\n1\n1\n1\n1\n1\n1\n\n\n\n01111111 转换为 10进制数是 127\n而如果是一个负数的话，第一位就是 1，能表示的最小负数就是\n\n\n\n1\n0\n0\n0\n0\n0\n0\n0\n\n\n\n读取时，发现第一位是 1，表明这是一个负数，那么就要按照读取负数的规则去读取数据\n首先减去 1\n\n\n\n0\n1\n1\n1\n1\n1\n1\n1\n\n\n\n按位取反\n\n\n\n1\n0\n0\n0\n0\n0\n0\n0\n\n\n\n10000000\t的十进制为 128\n得到\t10000000\t表示的负数的十进制值为 -128\n所以 8个带符号的二进制位能表示的数据范围为-128～127\n不带符号的很好理解，就是 0～255\n2 short 短整形java 中 short 类型为两个字节大小，16个二进制位，通过1.1可知\nshort 类型能表示的数字范围为  -2^15^～2^15^ -1\t-32768 ～ 32767\n3 int类型java 中 int 类型为4个字节大小，32个二进制位\nint 类型能表示的数字范围为 -2147483648 ~ 2147483647\n4 long类型java 中 long 类型为8个字节大小，64个二进制位\nlong 类型能表示的数字范围为 -9223372036854775808 ~ 9223372036854775807\n5 float类型java 中 long 类型为4个字节大小，32个二进制位\nlong 类型能表示的数字范围为 -2147483648 ~ 2147483647\n6 double类型java 中 double 类型为8个字节大小，64个二进制位\ndouble 类型能表示的数字范围为 -9223372036854775808 ~ 9223372036854775807\n7 boolean类型boolean 只表示一位信息\n只有两个值 true \tfalse\n默认值为 false\n8 char类型java 中 char 类型为两个字节大小，16个二进制位\n由于字符值没有正负之分，所以它的十进制等效值范围为0 ~ 65535\n注\n值得注意的是，java 中的浮点数类型 float、double，进行运算时并不能准确的得到结果\n\n这是因为，小数的二进制转换规则导致的\n小数的二进制转化规则是，\n将小数位拿出来 * 2，直到最后结果的小数位为 0 时结束\n例如 0.12\n0.12 * 2 &#x3D; 0.24 … 0\n0.24 * 2 &#x3D; 0.48 … 0\n0.48 * 2 &#x3D; 0.96 … 0\n0.96 * 2 &#x3D; 1.92 … 1\n0.92 * 2 &#x3D; 1.84 … 1\n0.84 * 2 &#x3D; 1.68 … 1\n…\n会一直乘下去\n所以最后 0.12 的二进制会变为\n0.000111…\n无限累加的数\n而计算机在存储小数位时是有长度限制的，所以最后存储的是一个有误差的值\n可以看出计算机无法精确的表示0.12这个十进制数字的值\n那么将它进行计算，肯定会导致误差\npublic static void main(String[] args) &#123;       float f1 = 2.12f;       float f2 = 0.31f;       System.out.println(f1 + f2);   &#125;\n\n以上代码，按照十进制的运算规则，打印结果应该是 2.43\n但是实际代码运行结果却是\n2.4299998\n\n\n\n编程语言都会有这种问题\n为了解决浮点数之间运算的精度问题，例如，如何判断两个浮点数是否相等呢？\n一般是判断两个浮点数之差的绝对值是否小于一个很小的数\nSystem.out.println( Math.abs(f1 - f2) &lt; 0.00001);\n\n\n\n另外 java 中提供了一个类 BigDecimal,可以用来对超过十六位有效位的数进行精确的运算\n上述代码中对 float 类型的数 f1 f2 相加得到的是一个有误差的结果\n将它改成使用 BigDecimal 的形式\npublic static void main(String[] args) &#123;       float f1 = 2.12f;       float f2 = 0.31f;       // System.out.println(f1 + f2); // 2.4299998  \t\t\tBigDecimal bd1 = new BigDecimal(&quot;2.12&quot;);       BigDecimal bd2 = new BigDecimal(&quot;0.31&quot;);       System.out.println(bd1.add(bd2));   &#125;\n\n这次得到的结果就是预期的 2.43\n使用 BigDecimal 进行 加 减 乘 时，精度不会丢失，但是做除法的时候，会存在除不尽的情况\n这个时候就要手动去指定保留的小数位\nBigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽\n\nBigDecimal 类提供了很多常用的计算方法，例如保留小数位，取商和余数等\n","tags":["java"]},{"title":"java泛型","url":"/2022/04/26/java%E6%B3%9B%E5%9E%8B/","content":"\n温故知新系列\n\n\n\nstep1了解泛型之前需要先考虑如下代码\ndouble d1 = 123d;Map map = new HashMap();map.put(&quot;key&quot;,d1);double d2 = (double) map.get(&quot;key&quot;);System.out.println(d2);\n\n以上代码会正常打印出 d2 的值\n123.0\n\n上述代码将 map.get(&quot;key&quot;) 的返回值强制转换为了一个 double 类型\n如果不写强制类型转换，编译器会直接提示错误警告\ndouble d2 = map.get(&quot;key&quot;);\n\n\n它告诉编写者，不能直接把一个 Object类型的值赋值给一个 double 类型\n也就是说 map.get 方法的返回值是一个 Object 类型\n为什么会是这样呢？map.put 存放进去的 值  明明是一个 double 数\n\n分析一下\n\nMap 是一个以 键值对 的形式存放数据的数据结构\n它允许以任何类型的值作为键(key)，任何类型的值作为值(value)\n由于Object是所有类型的超类\n所以 map.put(key,value)的两个形参都是 Object类型的\n这就实现了可以 以任何类型的值作为键(key)，任何类型的值作为值(value)\n执行以下代码时\nmap.put(&quot;key&quot;,d1);\n\nmap 把 key 和 value 都向上转型成了 Object 保存起来\n当通过 get(key) 去取到数据时，也返回的是转型之后的 Object 对象\n因为 map 自己并不会记录值的原始类型到底是哪一种，无论哪一种肯定都是 Object\n所以我们拿到 Object 对象之后需要进行一次对应的类型转换，成为我们需要的值\n这会导致一个问题\ndouble d1 = 123d;Map map = new HashMap();map.put(&quot;key&quot;,d1);double d2 = (double) map.get(&quot;key&quot;);System.out.println(d2);int i1 = (int)map.get(&quot;key&quot;);\n\n以上代码在编辑器中不会有任何问题，但是如果执行，第6行就会出现异常\njava.lang.Double cannot be cast to java.lang.Integer\n\n只看第六行的代码完全没有任何问题\nint i1 = (int)map.get(&quot;key&quot;);\n\n将一个 Object 类型强转为一个 int 类型在 java 语法中是允许的\n但是由于这个 key 中存放的实际值是一个 double 类型\n所以实际运行时会变成 将一个 double 类型强转换为一个 int 类型，这在 java 中是不允许的\n就会出现异常\ndouble d1 = 123d;Map map = new HashMap();map.put(&quot;key&quot;,d1);double d2 = (double) map.get(&quot;key&quot;);System.out.println(d2);\n\n\n上面的代码由于我们已经知道 key 对应的值类型为 double\n所以当我们通过 map.get(&quot;key&quot;)拿到返回的 Object 时\n已经知道该强转为哪一种类型，所以是完全没问题的\n\n但是如果现在我们只知道一个 map 和它的某一个 key，并不知道与这个 key 对应的 value 值是什么类型该怎么做呢？\n实际的工程代码中，想要查到这个 key 是在哪里、什么地方被 put 进 map 的，是不好查的\n所以我们只能拿到 map.get 之后的 Object 对象\n这个 Object 在被转换之前的原始类型是什么我们并不知道\n但是由于语法上 Object 可以被转换成任何一个类型\n所以编辑阶段是不会有任何提示的，只有运行时才能知道是否正确\nObject o = map.get(&quot;key1&quot;);// 可以将 o 转换成任意类型，编辑时不会有错误提示int n = (int)o;double d = (double)o;YourClass y = (YourClass)o;//... ...\n\n\n\n\n能否在 map 定义之初就指定这个 map 中的 键和值 的类型呢？\n调用 put、get 方法时的形参也按照指定的 键和值 的类型\n这样在编码时就能知道 此map中的 键和值 应该是什么类型\n\nstep2java1.5更新的泛型就解决了上述问题\n现在定义一个 map 的方式\nMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();\n\n此种方式指定了这个 map 的键值只能是一个 Integer 类型，对应的值只能是一个 String 类型\n这样在调用 map.put 方法时，可以直观的看到这个 map 的键值类型\n\n现在往 map 中存放两条键值对数据\nmap.put(1,&quot;firstValue&quot;);map.put(2,&quot;secondValue&quot;);\n\n然后 get 数据\nString s = map.get(1);System.out.println(s);// firstValue\n\n由于定义 map 之初就指定了 key 和 value 的类型，通过查看 map 的定义语句我们就能知道\n返回类型是什么，就用返回的类型同类型的变量去接收即可\n并且如果我们用一个其他类型的变量去接收，编辑器直接会提示代码错误\n\n解决了 step1中的问题\nstep3 定义泛型类型自定义一个泛型\npublic class Gen &lt;T&gt;&#123;    private T one;    private T two;    public Gen()&#123;&#125;    public Gen(T one,T two)&#123;        this.one = one;        this.two = two;    &#125;    public T getOne() &#123;        return one;    &#125;    public void setOne(T one) &#123;        this.one = one;    &#125;    public T getTwo() &#123;        return two;    &#125;    public void setTwo(T two) &#123;        this.two = two;    &#125;&#125;\n\n上述代码含义是，**一个泛型类型Gen，它的泛型T可以是任意一个类，属性 one、two 都是 T类型的对象 **\n我们可以指定它的泛型\npublic static void main(String[] args) &#123;  Gen&lt;Number&gt; numberGen = new Gen&lt;Number&gt;(123,456);&#125;\n\n上面我们指定了 numberGen 的泛型为 Number，现在 numberGen 的两个属性 one、two 就都是 Number 类型，且 set 方法的形参也都为 Number 类型\n再定义一个针对于 参数为 泛型是 Number 类型的 Gen 的方法\npublic static &lt;T&gt; int sum(Gen&lt;Number&gt; gen)&#123;  Number one = gen.getOne();  Number two = gen.getTwo();  return one.intValue() + two.intValue();&#125;\n\n这是一个简单的将 Gen 中的属性求和的方法，并且形参要求是一个 泛形为 Number 的 Gen 类型\n如果再定义一个泛型为 Integer 类型的 Gen ，调用 sum 方法求和呢？\npublic static void main(String[] args) &#123;       Gen&lt;Number&gt; numberGen = new Gen&lt;Number&gt;(123,456);       System.out.println(sum(numberGen));       Gen&lt;Integer&gt; integerGen = new Gen&lt;&gt;(1,5);       System.out.println(sum(integerGen));// 此处会有错误警告   &#125;   public static &lt;T&gt; int sum(Gen&lt;Number&gt; gen)&#123;       Number one = gen.getOne();       Number two = gen.getTwo();       return one.intValue() + two.intValue();   &#125;\n\n按照 java 的语法逻辑\nInteger 是 Number 的子类，那么可以向上转型为 Number\n而 sum 方法的形参中的 泛型 就是 Number，所以 integerGen 应该可以作为参数才对\n为什么不可以这么做？\n\n值得注意的是\n虽然 Integer 是 Number 的子类可以向上转型\n但是 sum 方法的形参是一个 泛型类型为 Number 的泛型类，并不是单纯的 Number\n而  Gen&lt;Integer&gt; integerGen并不是 Gen&lt;Number&gt; numberGen的子类，所以不可作为形参\n\nsum 方法的方法体对于一个 Number 或者 Number 的子类 同样适用\nNumber one = gen.getOne();Number two = gen.getTwo();return one.intValue() + two.intValue();\n\n有没有一种方式能够让 泛型是 Number 或者 Number 的子类的泛型对象 Gen 也能作为形参传入呢？\nstep4 上界通配符针对 step3 最后的问题，java 提供了一种方式可以做到\n改写 sum 方法\npublic static &lt;T&gt; int sum(Gen&lt;? extends Number&gt; gen)&#123;        Number one = gen.getOne();        Number two = gen.getTwo();        return one.intValue() + two.intValue();   \t&#125;\n\nGen&lt;? extends Number&gt; gen的含义是\n泛型类型形参 gen 的泛型可以是 Number 或者 Number 的子类\n这种方式叫做 上界通配符\n使用此种方式\n所有 泛型为 Number 或者 Number 子类的 Gen 都可以作为参数传递进来，得到 intValue 的和\n例如\nGen&lt;Integer&gt; integerGen = new Gen&lt;&gt;();Gen&lt;Double&gt; doubleGen = new Gen&lt;&gt;();Gen&lt;Float&gt; floatGen = new Gen&lt;&gt;();// ... ...\n\n现在 step3 中的代码就能正常执行了\npublic static void main(String[] args) &#123;       Gen&lt;Number&gt; numberGen = new Gen&lt;Number&gt;(123,456);       System.out.println(sum(numberGen));// 579       Gen&lt;Integer&gt; integerGen = new Gen&lt;&gt;(1,5);       System.out.println(sum(integerGen));// 6   &#125;   public static &lt;T&gt; int sum(Gen&lt;? extends Number&gt; gen)&#123;       Number one = gen.getOne();       Number two = gen.getTwo();       return one.intValue() + two.intValue();   &#125;\n\n\n\n注：\n使用上界通配符有一个需要注意的地方\n\n先修改一下 sum 方法代码\npublic static &lt;T&gt; int sum(Gen&lt;? extends Number&gt; gen)&#123;        Number one = gen.getOne();        Number two = gen.getTwo();                gen.setOne( new Integer(789) );// 此处会出现错误警告                return one.intValue() + two.intValue();    &#125;\n\n如果我们尝试在 sum 方法中修改 gen 的属性值，是不允许的\n按照以往的经验，拿到了一个对象，通过 set 方法去修改对象的属性值是没有问题的\n这里的原因是\n形参 gen 的泛型是 Number 或者它的子类，所以 set 方法的形参也是 Number 或者 其子类\n但是 Number 理论上可以有无数个子类，在 sum 方法中并不能知道此时的 gen 泛型到底是 Number 的哪一个子类\n所以 set 方法的形参到底是什么具体的类型在 sum 方法中无法知晓，而父类 Number 是无法转型为子类的\nset 方法就无法被正常调用\n只可以将其 set 为 null\ngen.setOne(null);\n\n除非特殊需要才会这样做，因为这样会导致后面取值调用时空指针异常\n由上面的分析得知\n使用上界通配符的方式可以读取 泛型类型中的泛型，但是无法修改 泛型类型中的泛型 -- 只读\nstep5 下界通配符上界通配符意义是 泛型可以是指定类型本身或者其子类\n下界通配符的意义是 泛型可以是指定类型本身或者其父类\n定义一个方法，参数使用 下界通配符 Gen&lt;? super Integer&gt; \npublic static &lt;T&gt; void set(Gen&lt;? super Integer&gt; gen,Integer one ,Integer two)&#123;        gen.setOne(one);        gen.setTwo(two);&#125;\n\n这是一个简单的将 泛型为 Integer 的 gen 中属性重新赋值的方法\n测试一下\npublic static void main(String[] args) &#123;        Gen&lt;Number&gt; numberGen = new Gen&lt;Number&gt;(123,456);        System.out.println(numberGen.getOne().intValue());// 123        // 重新赋值        set(numberGen,100,100);        System.out.println(numberGen.getOne().intValue());// 100        Gen&lt;Integer&gt; integerGen = new Gen&lt;Integer&gt;(1,5);        System.out.println(integerGen.getOne().intValue());// 1    \t// 重新赋值        set(integerGen,3,4);        System.out.println(integerGen.getOne().intValue());// 3    &#125;public static &lt;T&gt; void set(Gen&lt;? super Integer&gt; gen,Integer one ,Integer two)&#123;        gen.setOne(one);        gen.setTwo(two);&#125;\n\n可以看出 对于泛型是 Integer 或者其父类 Number，方法都可成功调用且修改属性 one 的值\n注：\n使用 下界通配符也有一个需要注意的地方\n\n修改一下 set 方法\npublic static &lt;T&gt; void set(Gen&lt;? super Integer&gt; gen,Integer one ,Integer two)&#123;        gen.setOne(one);        gen.setTwo(two);        Integer integer = gen.getOne();// 此处会出现错误警告            &#125;\n\n当我们试图在 set 方法中取到 gen 的属性值时，会有错误警告\n原因与 step4 中的上界通配符类似\n形参 gen 的泛型是 Integer 或者其父类,get 方法中返回的值也为 Integer 及其父类\n由于 set 方法中并不知道传递过来的 gen 实际的泛型是 Integer 还是其父类，虽然 Integer 的父类只能有一个我们可以找到\n但是 Integer 的父类也可以有父类，父类也可以有父类 ...\nGen&lt;? super Integer&gt; gen   其中的形参泛型可以是 Integer 及其父类、父类的父类 、父类的父类的父类 ...\n所以无法确定 gen.get方法的返回值类型到底是什么\n这就导致了 get 方法无法被正常调用\n想要拿到返回值只能使用 所有类型的父类 Object 去接收\nObject o = gen.getOne();\n\n但是这就导致了 step1 中相同的问题：无法知晓 Object 持有的到底是哪一种类型，如何做转换\n由上面的分析得知\n使用下界通配符的方式可以修改 泛型类型中的泛型，但是无法读取 泛型类型中的泛型 -- 只写\nstep6 实践如果现在需要一个方法：将一个Gen&lt;Number&gt;中的属性拷贝到另一个Gen&lt;Number&gt;中，就应该考虑到 step4 和  step5中的可读性和可写性问题\n public static &lt;T&gt; void copyT(Gen&lt;? super T&gt; t1 , Gen&lt;? extends T&gt; t2)&#123;        t1.setOne( t2.getOne() );        t1.setTwo( t2.getTwo() );    &#125;\n\n要将 g2 中的属性拷贝到 g1 中\ng2的数据是要被读取的，不需要去修改它的属性\t&#x3D;&#x3D;&#x3D;\t只读\ng1的数据是要被修改的，不需要取到它的属性\t&#x3D;&#x3D;&#x3D;\t只写\npublic static void main(String[] args) &#123;        Gen&lt;Float&gt; floatGen = new Gen&lt;Float&gt;(123f,345f);        Gen&lt;Float&gt; floatGen2 = new Gen&lt;Float&gt;(678f,9f);    \tSystem.out.println(floatGen2.getOne().floatValue());// 678。0        copyT(floatGen2,floatGen);        System.out.println(floatGen2.getOne().floatValue()); // 123.0&#125;public static &lt;T&gt; void copyT(Gen&lt;? super T&gt; t1 , Gen&lt;? extends T&gt; t2)&#123;        t1.setOne( t2.getOne() );        t1.setTwo( t2.getTwo() );    &#125;\n\n成功复制\n\njava Collentions类中的 copy 方法形参使用的就是此种形式\n\n\n\n综上可知：java 泛型实际上是一种抽象，T 可以表示任意一个 除基本数据类型外的类\n那么泛型类型就可以作为一个模板，持有除基本数据类型外的任意一个类\n很大程度上缩减了需要复写的代码\n\n","tags":["java"]},{"title":"java集合","url":"/2022/04/29/java%E9%9B%86%E5%90%88/","content":"\n温故知新系列\n\n\n\n\n\nList","tags":["java"]},{"title":"java注解","url":"/2022/04/23/java%E6%B3%A8%E8%A7%A3/","content":"\n温故知新系列\n\n\n\n1 关于Java 注解是一种可以被添加到 java 源代码中的元数据\n可以用来修饰 类、方法、参数、字段、包\n可以把它看作是一个标记，程序在编译和运行时可以检测到这些标记，从而进行对应的处理\n2 定义与定义 类、接口 类似，java 中定义注解也有特定的方式\n使用  @interface 定义一个注解\npublic @interface CheckField &#123;    int min() default 1;    int max() default 10;&#125;\n\n另外还需要指定注解可以使用的位置，java 中提供了可以 去修饰注解的注解，这类注解叫做元注解\n常用的有以下几类\n@Target 表示此注解可以被应用于哪些位置\n\n\n\nTarget类型\n描述\n\n\n\nElementType.TYPE\n可应用于类、接口（包括注解）、枚举\n\n\nElementType.FIELD\n应用于 属性(包括枚举中的常量)\n\n\nElementType.METHOD\n应用于 方法\n\n\nElementType.PARAMETER\n应用于 方法的形参\n\n\nElementType.CONSTRUCTOR\n应用于 构造函数\n\n\nElementType.LOCAL_VARIABLE\n应用于 局部变量\n\n\nElementType.ANNOTATION_TYPE\n应用于 注解类型\n\n\nElementType.PACKAGE\n应用于 包\n\n\nElementType.TYPE_PARAMETER\n1.8版本新增 应用于 类型变量\n\n\nElementType.TYPE_USE\n1.8版本新增，应用于任何使用类型的语句中，（例如声明语句、泛型和强制转换语句中的类型）\n\n\n@Retention 表明注解的生命周期\n\n\n\nRetention类型\n描述\n\n\n\nRetentionPolicy.SOURCE\n编译时被丢弃，不包含在类文件中\n\n\nRetentionPolicy.CLASS\nJVM加载时被丢弃，包含在类文件中，默认是此方式\n\n\nRetentionPolicy.RUNTIME\n由JVM加载，包含在类文件中，在运行时会被获取到，一般常用此方式\n\n\n@Document 表明注解可以被 javadoc 或者类型的工具文档化\n@Inherited 注解标记类的子类也会拥有这个注解\n且@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效\n将上述代码完善，表明注解的应用位置及生命周期\n@Target(&#123;        ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface CheckField &#123;    int min() default 1;    int max() default 10;&#125;\n\n此注解可以被应用到对象属性上，且会被 包含在类文件中，在运行时会被获取到\n3 处理代码中加上了注解，不会对已有的代码逻辑有任何影响\n也就是说加上注解，对应的处理需要我们自己完成，注解只是一个 标记\n前面定义好了一个 CheckField 注解，有两个属性值  min 和 max\n可以使用它验证对象属性中的字段长度是否符合要求\n定义一个 User 类，并且加上注解\npublic class User &#123;    @CheckField(min=5,max=20)    private String strName;    @CheckField(min=10,max=15)    private String strPassword;&#125;\n\n我们需要验证的是：\nstrName 的长度应该是 5 - 20\nstrPassword 的长度应该是 10 - 15\nmain 方法\n实例化一个 User 的对象，给属性赋一个不符合要求的值\n通过反射拿到所有的 Field，判断 当前 Field 是否存在 CheckField\n如果 Field 存在 CheckField 注解且是 String 类型\n那么当 Field 的值长度不符合 注解中的 min max 长度值范围时\n抛出非法数据异常\npublic static void main(String[] args) throws IllegalAccessException &#123;        User u = new User();        u.setStrName(&quot;a&quot;);        u.setStrPassword(&quot;12345678910&quot;);        for(Field field : u.getClass().getDeclaredFields())&#123;            if( field.isAnnotationPresent(CheckField.class) )&#123;                field.setAccessible(true);                CheckField checkField = field.getAnnotation(CheckField.class);                Object value = field.get(u);                if( value instanceof String )&#123;                    String s = (String) value;                    if(s.length() &lt; checkField.min() || s.length() &gt; checkField.max())&#123;                        throw new IllegalArgumentException(&quot;字段长度不符合要求：&quot;+field.getName());                    &#125;                &#125;            &#125;        &#125;    &#125;\n\n运行结果\nException in thread &quot;main&quot; java.lang.IllegalArgumentException: 字段长度不符合要求：strName\n\n\n\n注\n值得注意的是，上述代码中的 field.setAccessible(true);\n\n由于我们定义的 User 类属性是 private 私有的\npublic class User &#123;    @CheckField(min=5,max=20)    private String strName;    @CheckField(min=10,max=15)    private String strPassword;&#125;\n\n那么通过反射是无法访问私有属性的，需要给 field 加上可访问权限，才可以拿到进行使用\n\n 实际应用中，可以通过 注解 和 切面 相互配合的方式，实现诸如：判断属性值是否合法、记录操作日志等等功能\n\n","tags":["java"]}]